#!/usr/bin/perl
use strict;
use warnings;
use RPerl;
our $VERSION = 0.004_000;

## no critic qw(ProhibitUselessNoCritic ProhibitMagicNumbers RequireCheckedSyscalls) # USER DEFAULT 1: allow numeric values and print operator
## no critic qw(ProhibitExplicitStdin)  # USER DEFAULT 4: allow <STDIN>
## no critic qw(ProhibitBooleanGrep)  # SYSTEM SPECIAL 1: allow grep

use RPerl::Parser;    # includes Perl::Critic
use RPerl::Translator;
use RPerl::Generator;
use RPerl::Compiler;    # includes Inline
use Getopt::Long;

# move output away from initial Inline compiler output
RPerl::diag "\n\n";

# [[[ ACCEPT COMMAND-LINE ARGUMENTS ]]]
# [[[ ACCEPT COMMAND-LINE ARGUMENTS ]]]
# [[[ ACCEPT COMMAND-LINE ARGUMENTS ]]]

my integer $verbose                                    = 0;
my string__array_ref $rperl_input_file_names           = [];
my string__array_ref $rperl_input_file_names_unlabeled = [];
my string__array_ref $cpp_output_file_names            = [];
my string__hash_ref $mode = {}; # can't store defaults here, erased by GetOptions()
my string__hash_ref $mode_default = { ops => 'CPP', types => 'CPP' }; # default to CPPOPS_CPPTYPES
my array__hash_ref $modes_supported
    = { ops => ['CPP'], types => [ 'PERL', 'CPP' ] };
GetOptions(
    'debug'         => \$RPerl::DEBUG,
    'verbose'       => \$verbose,
    'infile=s{1,}'  => \$rperl_input_file_names,
    'outfile=s{1,}' => \$cpp_output_file_names,
    'mode=s%'       => \$mode,
    '<>'            => \&store_unlabeled_options
    )
    or croak(
    "\nERROR EARG00: Failure processing command line arguments,\ncroaking");

RPerl::diag q{in rperl, have $RPerl::DEBUG = } . $RPerl::DEBUG . "\n";
RPerl::diag q{in rperl, have $verbose = } . $verbose . "\n";

# accept unlabeled input file name(s) if no labeled values specified
if (    ( ( scalar @{$rperl_input_file_names} ) == 0 )
    and ( ( scalar @{$rperl_input_file_names_unlabeled} ) > 0 ) )
{
    $rperl_input_file_names = $rperl_input_file_names_unlabeled;
}

if ( ( scalar @{$rperl_input_file_names} ) == 0 ) {
    croak(
        "\nERROR EARG01: No RPerl source code input file(s) specified,\ncroaking"
    );
}

# check input file(s)
my integer $rperl_input_file_num = scalar @{$rperl_input_file_names};
for my integer $i ( 0 .. ( $rperl_input_file_num - 1 ) ) {
    my string $rperl_input_file_name = $rperl_input_file_names->[$i];

#    RPerl::diag 'in rperl, top of file checking loop ' . $i . ' of ' . $rperl_input_file_num . ", have \$rperl_input_file_names->[$i] = '" . $rperl_input_file_name . "'\n";

    if ( not( -e $rperl_input_file_name ) ) { ## no critic qw(ProhibitCascadingIfElse)  # SYSTEM DEFAULT 3: allow argument-handling logic
        croak(
            "\nERROR EARG02: Specified RPerl source code input file '$rperl_input_file_name' does not exist,\ncroaking"
        );
    }
    elsif ( not( -r $rperl_input_file_name ) ) {
        croak(
            "\nERROR EARG03: Specified RPerl source code input file '$rperl_input_file_name' is not readable,\ncroaking"
        );
    }
    elsif ( not( -f $rperl_input_file_name ) ) {
        croak(
            "\nERROR EARG04: Specified RPerl source code input file '$rperl_input_file_name' is not a plain file,\ncroaking"
        );
    }
    elsif ( ( $rperl_input_file_name !~ /[.]pm$/xms )
        and ( $rperl_input_file_name !~ /[.]pl$/xms ) )
    {
        croak(
            "\nERROR EARG05: Specified RPerl source code input file '$rperl_input_file_name' is not a Perl program ending  in '.pl' or module ending in '.pm',\ncroaking"
        );
    }

    # automatically generate output file name(s) if not provided
    if ( not( defined $cpp_output_file_names->[$i] ) ) {
        $cpp_output_file_names->[$i] = $rperl_input_file_name;
        substr $cpp_output_file_names->[$i], -3, 4, '.cpp';
    }

#    RPerl::diag 'in rperl, bottom of file checking loop ' . $i . ' of ' . $rperl_input_file_num . ", have \$cpp_output_file_names->[$i] = '" . $cpp_output_file_names->[$i] . "'\n";
}

# NEED FIX: Perl::Critic bug, without $dummy we get "Postfix control "foreach" used (See page 96 of PBP)"
my $dummy = 2;

# check modes
foreach my string $mode_key ( keys %{$mode} ) {
    if ( not( exists $modes_supported->{$mode_key} ) ) {
        croak(
            "\nERROR EARG06: Unsupported or invalid mode category '$mode_key' specified, supported categories are ("
                . join( ', ', keys %{$modes_supported} )
                . "),\ncroaking" );
    }
    elsif (
        not( grep { $_ eq $mode->{$mode_key} }
            @{ $modes_supported->{$mode_key} } )
        )
    {
        croak(    "\nERROR EARG07: Unsupported or invalid mode '"
                . $mode->{$mode_key}
                . "' in mode category '$mode_key' specified, supported modes are ("
                . join( ', ', @{ $modes_supported->{$mode_key} } )
                . "),\ncroaking" );
    }
}

# accept modes
foreach my string $mode_default_key ( keys %{$mode_default} ) { ## no critic qw(ProhibitPostfixControls)  # SYSTEM SPECIAL 7: PERL CRITIC UNFILED ISSUE, not postfix foreach
    if ( not( exists $mode->{$mode_default_key} ) ) {
        $mode->{$mode_default_key} = $mode_default->{$mode_default_key};
    }
}

if ( $verbose and ( $rperl_input_file_num > 1 ) ) {
    print "input file(s):\n";
    foreach my string $input_file_name ( @{$rperl_input_file_names} ) {
        print q{    } . $input_file_name . "\n";
    }
    print "output file(s):\n";
    foreach my string $output_file_name ( @{$cpp_output_file_names} ) {
        print q{    } . $output_file_name . "\n";
    }
    print "modes:\n";
    foreach my string $submode_key ( keys %{$mode} ) {
        print q{    } . $submode_key . ' => ' . $mode->{$submode_key} . "\n";
    }
    print "\nPRESS <ENTER> TO CONTINUE\n";
    my string $stdin_ignore = <STDIN>;
}

# allow omission of "-infile" on command line
#our void $store_unlabeled_options = sub {  # NEED FIX: can't define RPerl-style subroutines here?
sub store_unlabeled_options {
    ( my unknown $option ) = @_;
    if ( defined $rperl_input_file_names->[0] ) {
        croak(
            "\nERROR EARG08: Unlabeled RPerl source code input file option(s) specified, but labeled option(s) also specified, please choose either labeled or unlabeled,\ncroaking"
        );
    }
    push @{$rperl_input_file_names_unlabeled}, $option;
    return;
}

# [[[ COMPILE RPERL TO XS & BINARY ]]]
# [[[ COMPILE RPERL TO XS & BINARY ]]]
# [[[ COMPILE RPERL TO XS & BINARY ]]]

for my integer $i ( 0 .. ( $rperl_input_file_num - 1 ) ) {
    my string $rperl_input_file_name = $rperl_input_file_names->[$i];
    my string $cpp_output_file_name  = $cpp_output_file_names->[$i];

    if ($verbose) {
        system 'reset';
        print 'input file number: '
            . ( $i + 1 ) . ' of '
            . $rperl_input_file_num . "\n";
        print 'input file: ' . $rperl_input_file_name . "\n";
        print 'output file: ' . $cpp_output_file_name . "\n";
        print 'modes: ';
        foreach my string $submode_key ( keys %{$mode} ) {
            print $submode_key . ' => ' . $mode->{$submode_key} . ', ';
        }
        print "\nPRESS <ENTER> TO CONTINUE\n";
        my string $stdin_ignore = <STDIN>;
    }

    my integer $eval_retval = eval {
        rperl_to_xsbinary__compile( $rperl_input_file_name,
            $cpp_output_file_name, $mode );
    };

    if ( not defined $eval_retval ) {
        print $EVAL_ERROR;
    }

    if ($verbose) {
        print "\nPRESS <ENTER> TO CONTINUE\n";
        my string $stdin_ignore = <STDIN>;
    }
}
